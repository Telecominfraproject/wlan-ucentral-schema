{%
	// Helper functions
	function has_switch_config() {
		return capab.switch && length(capab.switch) > 0;
	}

	function has_board_network_config() {
		return board?.network;
	}

	function is_switch_platform() {
		return capab.platform == "switch";
	}

	// Configuration generation functions
	function generate_loopback_config() {
		let output = [];
		
		uci_comment(output, '# generated by base.uc');
		uci_comment(output, '### generate loopback interface configuration');
		
		uci_named_section(output, 'network.loopback', 'interface');
		uci_set_string(output, 'network.loopback.ifname', 'lo');
		uci_set_string(output, 'network.loopback.proto', 'static');
		uci_set_string(output, 'network.loopback.ipaddr', '127.0.0.1');
		uci_set_string(output, 'network.loopback.netmask', '255.0.0.0');

		return uci_output(output);
	}

	function generate_bridge_config() {
		let output = [];
		
		uci_comment(output, '### generate bridge device configuration');
		
		// UP bridge
		uci_named_section(output, 'network.up', 'device');
		uci_set_string(output, 'network.up.name', 'up');
		uci_set_string(output, 'network.up.type', 'bridge');
		uci_set_string(output, 'network.up.igmp_snooping', '1');
		uci_set_string(output, 'network.up.macaddr', capab.macaddr?.wan);
		
		// DOWN bridge (only for non-switch platforms)
		if (!is_switch_platform()) {
			uci_comment(output, '');
			uci_named_section(output, 'network.down', 'device');
			uci_set_string(output, 'network.down.name', 'down');
			uci_set_string(output, 'network.down.type', 'bridge');
			uci_set_string(output, 'network.down.igmp_snooping', '1');
			uci_set_string(output, 'network.down.macaddr', capab.macaddr?.lan);
		}
		
		// UP none interface
		uci_comment(output, '');
		uci_named_section(output, 'network.up_none', 'interface');
		uci_set_string(output, 'network.up_none.ifname', 'up');
		uci_set_string(output, 'network.up_none.proto', 'none');

		return uci_output(output);
	}

	function generate_switch_config() {
		if (!has_switch_config())
			return '';

		let output = [];
		
		uci_comment(output, '### generate switch configuration');
		
		for (let k, v in capab.switch) {
			uci_section(output, 'network.switch');
			uci_set_string(output, 'network.@switch[-1].name', v.name);
			uci_set_boolean(output, 'network.@switch[-1].reset', v.reset);
			uci_set_boolean(output, 'network.@switch[-1].enable_vlan', v.enable);
		}

		return uci_output(output);
	}

	function generate_board_network_config() {
		if (!has_board_network_config())
			return '';

		let output = [];
		
		uci_comment(output, '### generate board-specific network configuration');
		
		for (let k, v in board.network) {
			if (+v.none == 1) {
				let device_name = sprintf('%s_none', v.device);
				uci_named_section(output, sprintf('network.%s', device_name), 'interface');
				uci_set_string(output, sprintf('network.%s.proto', device_name), 'none');
				uci_set_string(output, sprintf('network.%s.device', device_name), v.device);
			}
		}

		return uci_output(output);
	}
%}

{{ generate_loopback_config() }}
{{ generate_bridge_config() }}
{{ generate_switch_config() }}
{{ generate_board_network_config() }}
