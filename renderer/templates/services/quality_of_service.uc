{% 
// generated by quality_of_service.uc

// Helper functions
function has_qos_enabled() {
	return quality_of_service && length(quality_of_service.select_ports || []) > 0;
}

function get_qos_egress_interfaces() {
	if (!quality_of_service)
		return [];
	return ethernet.lookup_by_select_ports(quality_of_service.select_ports);
}

function get_interface_speed(dev, configured_speed) {
	if (configured_speed)
		return configured_speed;
	return ethernet.get_speed(dev);
}

function get_protocols_for_rule(protocol) {
	if (protocol == "any")
		return [ "udp", "tcp" ];
	return [ protocol ];
}

function has_port_range(port_config) {
	return port_config.range_end && port_config.range_end != port_config.port;
}

function has_classifier_rules() {
	return quality_of_service && quality_of_service.classifier && length(quality_of_service.classifier) > 0;
}

function has_services_defined() {
	return quality_of_service && quality_of_service.services && length(quality_of_service.services) > 0;
}

function has_bulk_detection() {
	return quality_of_service && quality_of_service.bulk_detection;
}

// Configuration generation functions
function generate_qosify_config() {
	if (!quality_of_service)
		quality_of_service = {};
	
	let egress = get_qos_egress_interfaces();
	let enable = has_qos_enabled();
	
	services.set_enabled("qosify", enable);
	
	if (!enable)
		return '';

	let output = [];
	
	uci_comment(output, '### generate QoS bulk detection defaults');
	let bulk_pps = has_bulk_detection() ? quality_of_service.bulk_detection.packets_per_second || 0 : 0;
	let bulk_dscp = has_bulk_detection() ? quality_of_service.bulk_detection.dscp : null;
	
	uci_set_number(output, 'qosify.@defaults[0].bulk_trigger_pps', bulk_pps);
	if (bulk_dscp)
		uci_set_string(output, 'qosify.@defaults[0].dscp_bulk', bulk_dscp);
	
	uci_comment(output, '### generate QoS device configuration');
	for (let dev in egress) {
		uci_named_section(output, `qosify.${dev}`, 'device');
		uci_set_string(output, `qosify.${dev}.name`, dev);
		uci_set_string(output, `qosify.${dev}.bandwidth_up`, sprintf('%dmbit', get_interface_speed(dev, quality_of_service.bandwidth_up)));
		uci_set_string(output, `qosify.${dev}.bandwidth_down`, sprintf('%dmbit', get_interface_speed(dev, quality_of_service.bandwidth_down)));
	}
	
	return uci_output(output);
}

function generate_qosify_rules() {
	if (!has_qos_enabled())
		return;
	
	let fs = require("fs");
	let file = fs.open("/tmp/qosify.conf", "w");
	
	// Generate classifier rules
	if (has_classifier_rules()) {
		for (let class in quality_of_service.classifier) {
			// Port-based rules
			if (class.ports) {
				for (let port in class.ports) {
					for (let proto in get_protocols_for_rule(port.protocol)) {
						let port_spec = sprintf("%d", port.port);
						if (has_port_range(port))
							port_spec += sprintf("-%d", port.range_end);
						
						let reclassify_prefix = port.reclassify ? "" : "+";
						file.write(sprintf("%s:%s %s%s\n", proto, port_spec, reclassify_prefix, class.dscp));
					}
				}
			}
			
			// DNS-based rules  
			if (class.dns) {
				for (let fqdn in class.dns) {
					let domain = fqdn.suffix_matching ? sprintf("*.%s", fqdn.fqdn) : fqdn.fqdn;
					let reclassify_prefix = fqdn.reclassify ? "" : "+";
					file.write(sprintf("dns:%s %s%s\n", domain, reclassify_prefix, class.dscp));
				}
			}
		}
	}
	
	// Generate service-based rules (TODO: implement when fs mocking is fixed)
	if (has_services_defined()) {
		// Note: This section requires proper fs mocking to work in tests
		// Will be implemented during services functionality enhancement
	}
	
	file.close();
}

// Main logic
generate_qosify_rules();
%}
{{ generate_qosify_config() }}
