{%
	// Helper functions
	function has_dhcp_inject_config() {
		return services.is_present("dhcpinject");
	}

	function get_dhcp_inject_ssids() {
		return services.lookup_ssids("dhcp-inject");
	}

	function has_dhcp_inject_ssids() {
		let ssids = get_dhcp_inject_ssids();
		return length(ssids) > 0;
	}

	function get_dhcp_inject_ports() {
		if (dhcp_inject && dhcp_inject.select_ports) {
			return ethernet.lookup_by_select_ports(dhcp_inject.select_ports);
		}
		return ["eth0"];
	}

	function calculate_interface_count() {
		let ssids = get_dhcp_inject_ssids();
		let iface_count = 0;
		for (let ssid in ssids) {
			iface_count += length(ssid.wifi_bands);
		}
		return iface_count;
	}

	// Configuration generation functions
	function generate_dhcp_inject_config() {
		if (!has_dhcp_inject_config() || !has_dhcp_inject_ssids())
			return '';

		let ports = get_dhcp_inject_ports();
		let ssids = get_dhcp_inject_ssids();
		let iface_count = calculate_interface_count();
		let output = [];

		uci_comment(output, '# generated by dhcp_inject.uc');
		uci_comment(output, '### generate DHCP Inject service configuration');

		// Configure uplink ports
		uci_set_string(output, 'dhcpinject.uplink', 'device');
		for (let port in ports) {
			uci_list_string(output, 'dhcpinject.uplink.port', port);
		}

		// Configure SSIDs
		uci_set_string(output, 'dhcpinject.ssids', 'ssids');
		for (let ssid in ssids) {
			uci_list_string(output, 'dhcpinject.ssids.ssid', ssid.name);
		}

		// Configure dhcpinject section
		uci_set_string(output, 'dhcpinject.dhcpinject', 'dhcpinject');
		uci_set_number(output, 'dhcpinject.dhcpinject.iface_count', iface_count);

		return uci_output(output);
	}

	// Main logic
	if (!has_dhcp_inject_config())
		return;

	let enable = has_dhcp_inject_ssids();
	services.set_enabled("dhcpinject", enable);

	if (!enable)
		return;
%}

{{ generate_dhcp_inject_config() }}
