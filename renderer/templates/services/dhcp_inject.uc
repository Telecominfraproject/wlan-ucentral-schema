{%
	// Helper functions
	function has_dhcp_inject_interfaces() {
		let interfaces = services.lookup_interfaces_by_ssids("dhcp-inject");

		return length(interfaces) > 0;
	}

	function get_dhcp_inject_interfaces() {
		return services.lookup_interfaces_by_ssids("dhcp-inject");
	}

	function get_upstream_interfaces() {
		let interfaces = get_dhcp_inject_interfaces();
		let upstreams = [];

		for (let iface in interfaces) {
			if (iface.role == "upstream")
				push(upstreams, iface);
		}

		return upstreams;
	}

	function has_upstream_interfaces() {
		return length(get_upstream_interfaces()) > 0;
	}

	// Configuration generation functions
	function generate_dhcp_inject_config() {
		let upstreams = get_upstream_interfaces();
		let enabled = has_upstream_interfaces();

		services.set_enabled("dhcpinject", enabled);

		if (!enabled)
			return '';

		let output = [];

		uci_comment(output, '# generated by dhcp_inject.uc');
		uci_comment(output, '### generate DHCP Inject service configuration');

		for (let upstream in upstreams) {
			let iface_name = ethernet.calculate_name(upstream);
			let count = 0;
			let freqs = [];

			uci_named_section(output, `dhcpinject.${upstream.name}`, 'network');
			uci_set_string(output, `dhcpinject.${upstream.name}.upstream`, iface_name);

			for (let ssid in upstream.ssids) {
				count += length(ssid.wifi_bands);

				for (let freq in ssid.wifi_bands) {
					push(freqs, freq);
					uci_list_string(output, `dhcpinject.${upstream.name}.ssid${freq}`, ssid.name);
				}
			}

			for (let freq in uniq(freqs))
				uci_list_string(output, `dhcpinject.${upstream.name}.freq`, freq);

			uci_set_number(output, `dhcpinject.${upstream.name}.count`, count);
		}

		return uci_output(output);
	}

	// Main logic
	if (!has_dhcp_inject_interfaces())
		return;
%}

{{ generate_dhcp_inject_config() }}
