{% 
// generated by radius_proxy.uc

// Helper functions
function has_radius_proxy_service() {
	return services.is_present("radsecproxy");
}

function has_radius_proxy_config() {
	return radius_proxy && radius_proxy.realms && length(radius_proxy.realms) > 0;
}

function has_radius_proxy_enabled() {
	return has_radius_proxy_service() && has_radius_proxy_config();
}

function is_radsec_realm(realm) {
	return realm.protocol == "radsec";
}

function is_radius_realm(realm) {
	return realm.protocol == "radius";
}

function is_block_realm(realm) {
	return realm.protocol == "block";
}

function has_local_certificates(realm) {
	return realm.use_local_certificates;
}

function has_custom_certificates(realm) {
	return realm.ca_certificate && realm.certificate && realm.private_key;
}

function validate_radsec_certificates(realm) {
	return has_local_certificates(realm) || has_custom_certificates(realm);
}

function has_accounting_server(realm) {
	return realm.acct_server;
}

function get_radsec_certificates(idx, realm) {
	let certs = {};
	
	if (has_local_certificates(realm)) {
		cursor.load('system');
		certs = cursor.get_all('system', '@certificates[-1]');
	} else if (has_custom_certificates(realm)) {
		certs.ca = files.add_anonymous(location, sprintf('ca%d', idx), b64dec(realm.ca_certificate));
		certs.cert = files.add_anonymous(location, sprintf('cert%d', idx), b64dec(realm.certificate));
		certs.key = files.add_anonymous(location, sprintf('key%d', idx), b64dec(realm.private_key));
	} else {
		return null;
	}
	
	return certs;
}

function generate_radsec_realm_config(idx, realm, output) {
	uci_comment(output, sprintf('### generate radsec realm configuration %d', idx));
	
	// Validate certificates
	let certs = get_radsec_certificates(idx, realm);
	if (!certs) {
		warn('invalid certificate settings for radsec realm');
		return;
	}
	
	// TLS configuration
	uci_named_section(output, sprintf('radsecproxy.tls%d', idx), 'tls');
	uci_set_string(output, 'radsecproxy.@tls[-1].name', sprintf('tls%d', idx));
	uci_set_string(output, 'radsecproxy.@tls[-1].CACertificateFile', certs.ca);
	uci_set_string(output, 'radsecproxy.@tls[-1].certificateFile', certs.cert);
	uci_set_string(output, 'radsecproxy.@tls[-1].certificateKeyFile', certs.key);
	uci_set_string(output, 'radsecproxy.@tls[-1].certificateKeyPassword', '');
	
	// Server configuration  
	uci_named_section(output, sprintf('radsecproxy.server%d', idx), 'server');
	uci_set_string(output, 'radsecproxy.@server[-1].name', sprintf('server%d', idx));
	
	if (realm.auto_discover) {
		uci_set_string(output, 'radsecproxy.@server[-1].dynamicLookupCommand', '/usr/libexec/naptr_lookup.sh');
	} else {
		uci_set_string(output, 'radsecproxy.@server[-1].host', realm.host);
		uci_set_string(output, 'radsecproxy.@server[-1].port', realm.port);
		uci_set_string(output, 'radsecproxy.@server[-1].secret', realm.secret);
	}
	
	uci_set_string(output, 'radsecproxy.@server[-1].type', 'tls');
	uci_set_string(output, 'radsecproxy.@server[-1].tls', sprintf('tls%d', idx));
	uci_set_string(output, 'radsecproxy.@server[-1].statusServer', '0');
	uci_set_string(output, 'radsecproxy.@server[-1].certificateNameCheck', '0');
	
	// Realm mappings
	for (let name in realm.realm) {
		uci_section(output, 'radsecproxy realm');
		uci_set_string(output, 'radsecproxy.@realm[-1].name', name);
		uci_set_string(output, 'radsecproxy.@realm[-1].server', sprintf('server%d', idx));
		uci_set_string(output, 'radsecproxy.@realm[-1].accountingServer', sprintf('server%d', idx));
	}
}

function generate_radius_realm_config(idx, realm, output) {
	uci_comment(output, sprintf('### generate radius realm configuration %d', idx));
	
	// Auth server
	uci_named_section(output, sprintf('radsecproxy.server%dauth', idx), 'server');
	uci_set_string(output, 'radsecproxy.@server[-1].name', sprintf('server%dauth', idx));
	uci_set_string(output, 'radsecproxy.@server[-1].host', realm.auth_server);
	uci_set_string(output, 'radsecproxy.@server[-1].port', realm.auth_port);
	uci_set_string(output, 'radsecproxy.@server[-1].secret', realm.auth_secret);
	uci_set_string(output, 'radsecproxy.@server[-1].type', 'udp');
	
	// Accounting server (optional)
	if (has_accounting_server(realm)) {
		uci_named_section(output, sprintf('radsecproxy.server%dacct', idx), 'server');
		uci_set_string(output, 'radsecproxy.@server[-1].name', sprintf('server%dacct', idx));
		uci_set_string(output, 'radsecproxy.@server[-1].host', realm.acct_server);
		uci_set_string(output, 'radsecproxy.@server[-1].port', realm.acct_port);
		uci_set_string(output, 'radsecproxy.@server[-1].secret', realm.acct_secret);
		uci_set_string(output, 'radsecproxy.@server[-1].type', 'udp');
	}
	
	// Realm mappings
	for (let name in realm.realm) {
		uci_section(output, 'radsecproxy realm');
		uci_set_string(output, 'radsecproxy.@realm[-1].name', name);
		uci_set_string(output, 'radsecproxy.@realm[-1].server', sprintf('server%dauth', idx));
		if (has_accounting_server(realm)) {
			uci_set_string(output, 'radsecproxy.@realm[-1].accountingServer', sprintf('server%dacct', idx));
		}
	}
}

function generate_block_realm_config(idx, realm, output) {
	uci_comment(output, sprintf('### generate block realm configuration %d', idx));
	
	// Block realm mappings
	for (let name in realm.realm) {
		uci_section(output, 'radsecproxy realm');
		uci_set_string(output, 'radsecproxy.@realm[-1].name', name);
		uci_set_string(output, 'radsecproxy.@realm[-1].replyMessage', realm.message);
	}
}

// Configuration generation functions
function generate_radius_proxy_config() {
	if (!has_radius_proxy_enabled()) {
		services.set_enabled("radsecproxy", false);
		return '';
	}
	
	services.set_enabled("radsecproxy", true);
	
	let output = [];
	
	uci_comment(output, '# generated by radius_proxy.uc');
	uci_comment(output, '### generate RADIUS proxy base configuration');
	
	// Base options
	uci_section(output, 'radsecproxy options');
	uci_list_string(output, 'radsecproxy.@options[-1].ListenUDP', 'localhost:1812');
	uci_list_string(output, 'radsecproxy.@options[-1].ListenUDP', 'localhost:1813');
	
	// Client configuration  
	uci_section(output, 'radsecproxy client');
	uci_set_string(output, 'radsecproxy.@client[-1].name', 'client');
	uci_set_string(output, 'radsecproxy.@client[-1].host', 'localhost');
	uci_set_string(output, 'radsecproxy.@client[-1].type', 'udp');
	uci_set_string(output, 'radsecproxy.@client[-1].secret', radius_proxy.proxy_secret);
	
	// Generate realm configurations
	for (let idx, realm in radius_proxy.realms) {
		if (is_radsec_realm(realm)) {
			generate_radsec_realm_config(idx, realm, output);
		} else if (is_radius_realm(realm)) {
			generate_radius_realm_config(idx, realm, output);
		} else if (is_block_realm(realm)) {
			generate_block_realm_config(idx, realm, output);
		}
	}
	
	return uci_output(output);
}

// Main logic
%}
{{ generate_radius_proxy_config() }}
