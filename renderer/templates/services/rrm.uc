{%
// generated by rrm.uc

// 1. Early validation and setup
if (!services.is_present("rrmd"))
	return;
services.set_enabled("rrmd", true);

// 2. Helper functions

// normalize_ functions - data transformation
function normalize_interval_to_ms(seconds) {
	return (seconds || 240) * 1000;
}

function normalize_algo_name(algo_name) {
	switch(algo_name) {
		case 'rcs':
			return 1;
		case 'acs':
			return 2;
		default:
			return 0;
	}
}

// has_ functions - check for existence/availability
function has_chanutil_policy(config) {
	return config?.rrm?.chanutil;
}

// 3. Configuration generation functions

function generate_base_config(config) {
	if (!config?.rrm)
		return '';

	let output = [];
	
	uci_comment(output, '### generate RRM base configuration');
	uci_set_boolean(output, 'rrmd.@base[0].beacon_request_assoc', config.rrm?.beacon_request_assoc || false);
	uci_set_number(output, 'rrmd.@base[0].station_stats_interval', config.rrm?.station_stats_interval || 0);
	
	return uci_output(output);
}

function generate_chanutil_policy(config) {
	if (!has_chanutil_policy(config))
		return '';

	let chanutil = config.rrm.chanutil;
	let output = [];
	
	uci_comment(output, '### generate RRM channel utilization policy');
	uci_section(output, 'rrmd policy');
	uci_set_string(output, 'rrmd.@policy[-1].name', 'chanutil');
	uci_set_number(output, 'rrmd.@policy[-1].interval', normalize_interval_to_ms(chanutil?.interval));
	uci_set_number(output, 'rrmd.@policy[-1].threshold', chanutil?.threshold || 0);
	uci_set_number(output, 'rrmd.@policy[-1].consecutive_threshold_breach', chanutil?.consecutive_threshold_breach || 1);
	uci_set_number(output, 'rrmd.@policy[-1].algo', normalize_algo_name(chanutil?.algo));
	
	return uci_output(output);
}

// 4. Template data preparation
let template_data = {
	rrm: rrm
};
%}

{{ generate_base_config(template_data) }}
{{ generate_chanutil_policy(template_data) }}