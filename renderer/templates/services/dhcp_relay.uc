{%
	// Helper functions
	function has_dhcp_relay_service() {
		return services.is_present("dhcprelay");
	}

	function has_dhcp_relay_config() {
		return dhcp_relay != null;
	}

	function get_dhcp_relay_interfaces() {
		return services.lookup_interfaces("dhcp-relay");
	}

	function has_dhcp_relay_interfaces() {
		let interfaces = get_dhcp_relay_interfaces();

		return length(interfaces) > 0;
	}

	function get_dhcp_relay_ports() {
		if (!dhcp_relay || !dhcp_relay.select_ports)
			return [];

		return ethernet.lookup_by_select_ports(dhcp_relay.select_ports);
	}

	function has_dhcp_relay_ports() {
		let ports = get_dhcp_relay_ports();

		return length(ports) > 0;
	}

	function get_dhcp_relay_vlans() {
		if (!dhcp_relay || !dhcp_relay.vlans)
			return [];

		return dhcp_relay.vlans;
	}

	function has_dhcp_relay_vlans() {
		let vlans = get_dhcp_relay_vlans();
	
		return length(vlans) > 0;
	}

	// Configuration generation functions
	function generate_firewall_rules() {
		let output = [];
		let upstream_interface = ethernet.find_interface("upstream", 0);

		uci_comment(output, '### generate DHCP Relay firewall rules');
		uci_set_string(output, 'firewall.dhcp_relay', 'rule');
		uci_set_string(output, 'firewall.dhcp_relay.name', 'Allow-DHCP-Relay');
		uci_set_string(output, 'firewall.dhcp_relay.src', upstream_interface);
		uci_set_string(output, 'firewall.dhcp_relay.dest_port', '67');
		uci_set_string(output, 'firewall.dhcp_relay.family', 'ipv4');
		uci_set_string(output, 'firewall.dhcp_relay.proto', 'udp');
		uci_set_string(output, 'firewall.dhcp_relay.target', 'ACCEPT');

		return uci_output(output);
	}

	function generate_relay_config() {
		let ports = get_dhcp_relay_ports();
		let vlans = get_dhcp_relay_vlans();
		let output = [];

		uci_comment(output, '### generate DHCP Relay service configuration');
		
		// Configure relay bridge
		uci_set_string(output, 'dhcprelay.relay', 'bridge');
		uci_set_string(output, 'dhcprelay.relay.name', 'up');

		// Add VLANs to relay
		for (let vlan in vlans)
			uci_list_string(output, 'dhcprelay.relay.vlans', vlan.vlan);

		// Add upstream ports
		for (let port in ports)
			uci_list_string(output, 'dhcprelay.relay.upstream', port);

		return uci_output(output);
	}

	function generate_vlan_configs() {
		let vlans = get_dhcp_relay_vlans();
		let output = [];

		uci_comment(output, '### generate DHCP Relay VLAN configurations');

		for (let vlan in vlans) {
			let vlan_section = 'dhcprelay.vlan' + vlan.vlan;
			uci_set_string(output, vlan_section, 'config');
			uci_set_string(output, vlan_section + '.server', vlan.relay_server);
			
			if (vlan.circuit_id_format)
				uci_set_string(output, vlan_section + '.circuit_id', vlan.circuit_id_format);
			
			if (vlan.remote_id_format)
				uci_set_string(output, vlan_section + '.remote_id', vlan.remote_id_format);
		}

		return uci_output(output);
	}

	function generate_dhcp_relay_config() {
		if (!has_dhcp_relay_service() || !has_dhcp_relay_config())
			return '';

		if (!has_dhcp_relay_interfaces() || !has_dhcp_relay_ports())
			return '';

		let output = [];
		
		uci_comment(output, '# generated by dhcp_relay.uc');
		
		// Generate all sections
		let firewall_output = generate_firewall_rules();
		if (firewall_output)
			push(output, firewall_output);
		
		let relay_output = generate_relay_config();
		if (relay_output)
			push(output, relay_output);
		
		// Generate VLAN configurations if present
		if (has_dhcp_relay_vlans()) {
			let vlan_output = generate_vlan_configs();
			if (vlan_output)
				push(output, vlan_output);
		}

		return uci_output(output);
	}

	// Main logic
	if (!has_dhcp_relay_service() || !has_dhcp_relay_config()) {
		return;
	}

	let enable = has_dhcp_relay_interfaces() && has_dhcp_relay_ports();
	services.set_enabled("dhcprelay", enable);

	if (!enable)
		return;
%}

{{ generate_dhcp_relay_config() }}
