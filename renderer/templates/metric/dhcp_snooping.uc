{%
// generated by dhcp_snooping.uc

// 1. Early validation and setup
let interfaces = services.lookup_interfaces("dhcp-snooping");
if (!length(interfaces))
	return;

// 2. Helper functions

// has_ functions - check for existence/availability
function has_filter_config(config) {
	return config?.dhcp_snooping?.filters && length(config.dhcp_snooping.filters) > 0;
}

function has_downstream_interfaces(interface_list) {
	for (let interface in interface_list) {
		if (interface.role === "downstream")
			return true;
	}
	return false;
}

// 3. Configuration generation functions

function generate_event_config(config) {
	let output = [];
	
	uci_comment(output, '### generate DHCP snooping event configuration');
	uci_named_section(output, 'event.dhcp', 'event');
	uci_set_string(output, 'event.dhcp.type', 'dhcp');
	uci_set_string(output, 'event.dhcp.filter', '*');
	
	// Apply specific filters if configured
	if (has_filter_config(config)) {
		for (let n, filter in config.dhcp_snooping.filters) {
			if (n === 0) {
				uci_set_string(output, 'event.dhcp.filter', filter);
			} else {
				uci_list_string(output, 'event.dhcp.filter', filter);
			}
		}
	}
	
	return uci_output(output);
}

function generate_device_config(interface_list) {
	if (!has_downstream_interfaces(interface_list))
		return '';
		
	let output = [];
	
	uci_comment(output, '### generate DHCP snooping device configuration');
	
	for (let interface in interface_list) {
		if (interface.role !== "downstream") 
			continue;
			
		let name = ethernet.calculate_name(interface);
		uci_section(output, 'dhcpsnoop device');
		uci_set_string(output, 'dhcpsnoop.@device[-1].name', name);
		uci_set_boolean(output, 'dhcpsnoop.@device[-1].ingress', true);
		uci_set_boolean(output, 'dhcpsnoop.@device[-1].egress', true);
	}
	
	return uci_output(output);
}

// 4. Template data preparation
let template_data = {
	dhcp_snooping: dhcp_snooping
};
%}

{{ generate_event_config(template_data) }}
{{ generate_device_config(interfaces) }}