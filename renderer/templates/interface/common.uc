{%
	// Helper functions

	// has_ functions - check for existence/availability
	function has_multiple_afnames(afnames) {
		return length(afnames) >= 2;
	}

	function has_downstream_vlan() {
		return interface.role == "downstream" && ethernet.has_vlan(interface);
	}

	// is_ functions - boolean checks/validation
	function is_static_addressing() {
		return ipv4_mode == 'static' || ipv6_mode == 'static';
	}

	function is_ipv4_dynamic(afnames, afidx) {
		return (length(afnames) == 1 || afidx == 0) && ipv4_mode == 'dynamic';
	}

	function is_ipv6_dynamic(afnames, afidx) {
		return (length(afnames) == 1 || afidx == 1) && ipv6_mode == 'dynamic';
	}

	function is_ipv4_enabled(afnames, afidx) {
		return (length(afnames) == 1 && ipv4_mode != 'none') || (afidx == 0 && ipv4_mode != 'none');
	}

	function is_ipv6_enabled(afnames, afidx) {
		return (length(afnames) == 1 && ipv6_mode != 'none') || (afidx == 1 && ipv6_mode != 'none');
	}

	// match_ functions - value mapping/selection
	function match_protocol(afnames, afidx) {
		if (is_static_addressing())
			return 'static';
		else if (is_ipv4_dynamic(afnames, afidx))
			return 'dhcp';
		else if (is_ipv6_dynamic(afnames, afidx))
			return 'dhcpv6';
		else
			return 'none';
	}

	// Configuration generation functions
	function generate_base_interface_config() {
		let afnames = ethernet.calculate_names(interface);

		if (!has_multiple_afnames(afnames))
			return '';

		let output = [];

		uci_comment(output, '# generated by interface/common.uc');
		uci_comment(output, '### generate base interface configuration');
		uci_named_section(output, `network.${netdev}`, 'interface');
		uci_set_string(output, `network.${netdev}.ucentral_name`, interface.name);
		uci_set_string(output, `network.${netdev}.ucentral_path`, location);
		uci_set_string(output, `network.${netdev}.ifname`, netdev);
		uci_set_number(output, `network.${netdev}.metric`, interface.metric);
		uci_set_string(output, `network.${netdev}.proto`, 'none');

		return uci_output(output);
	}

	function generate_af_interface_config(afname, afnames, afidx) {
		let output = [];

		if (afidx == 0) {
			uci_comment(output, '# generated by interface/common.uc');
			uci_comment(output, '### generate address family interface configuration');
		}

		uci_named_section(output, `network.${afname}`, 'interface');
		uci_set_string(output, `network.${afname}.ucentral_name`, interface.name);
		uci_set_string(output, `network.${afname}.ucentral_path`, location);
		uci_set_string(output, `network.${afname}.ifname`, netdev);
		uci_set_number(output, `network.${afname}.metric`, interface.metric);
		uci_set_number(output, `network.${afname}.mtu`, interface.mtu);
		uci_set_string(output, `network.${afname}.type`, interface.type);
		uci_set_boolean(output, `network.${afname}.auto`, interface.auto_start);
		uci_set_string(output, `network.${afname}.proto`, match_protocol(afnames, afidx));

		return uci_output(output);
	}

	function generate_routing_rule(afname) {
		if (!has_downstream_vlan())
			return '';

		let output = [];

		uci_comment(output, '### generate routing rule');
		uci_section(output, 'network rule');
		uci_set_string(output, 'network.@rule[-1].in', afname);
		uci_set_string(output, 'network.@rule[-1].lookup', routing_table.get(interface.vlan.id));

		return uci_output(output);
	}

	function generate_ipv4_config(afname) {
		let output = [];

		uci_comment(output, '### generate IPv4 configuration');

		return uci_output(output);
	}

	function generate_ipv6_config(afname) {
		let output = [];

		uci_comment(output, '### generate IPv6 configuration');

		return uci_output(output);
	}

	// Main logic
	let afnames = ethernet.calculate_names(interface);
%}

{{ generate_base_interface_config() }}

{%	for (let afidx, afname in afnames): %}
{{ generate_af_interface_config(afname, afnames, afidx) }}
{{ generate_routing_rule(afname) }}
{%		if (is_ipv4_enabled(afnames, afidx)): %}
{%   			include('ipv4.uc', { name: afname }) %}
{%		endif %}
{%		if (is_ipv6_enabled(afnames, afidx)): %}
{%			include('ipv6.uc', { name: afname }) %}
{%		endif %}
{%	endfor %}
