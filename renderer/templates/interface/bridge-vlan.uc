{%
	// Constants
	const TUNNEL_PROTOCOLS = {
		mesh: 'mesh',
		vxlan: 'vxlan',
		gre: 'gre',
		gre6: 'gre6'
	};

	const TUNNEL_PORT_FORMATS = {
		mesh: 'batman',
		vxlan: '_vx',
		gre: 'gre4t-gre.',
		gre6: 'gre6t-greip6.'
	};

	// Helper functions

	// has_ functions - check for existence/availability
	function has_tunnel_protocol() {
		return !!interface.tunnel?.proto;
	}

	function has_bridge_config() {
		return !!interface.bridge;
	}

	function has_vlan_awareness() {
		return !!interface.vlan_awareness?.first;
	}

	function has_vxlan_overlay() {
		return 'vxlan-overlay' in interface.services;
	}

	function has_wan_port() {
		return "WAN" in ethernet.ports;
	}

	function has_ethernet_swconfig(dev) {
		return ethernet.swconfig && ethernet.swconfig[dev];
	}

	function has_switch_port(port) {
		return !!port.switch;
	}

	// is_ functions - boolean checks/validation
	function is_tunnel_protocol(proto) {
		return interface.tunnel?.proto == proto;
	}

	function is_upstream_interface() {
		return interface.role == 'upstream';
	}

	function is_downstream_interface() {
		return interface.role == 'downstream';
	}

	function is_vlan_configured() {
		return !!interface.vlan.id;
	}

	function is_bridge_isolated() {
		return interface.bridge.isolate_ports || interface.isolate_hosts;
	}

	// normalize_ functions - data transformation
	function normalize_section_name(port) {
		return replace(port, '.', '_');
	}

	function normalize_vlan_range() {
		let vlan = interface.vlan_awareness.first;
		if (interface.vlan_awareness.last)
			vlan += '-' + interface.vlan_awareness.last;
		return vlan;
	}

	function normalize_batman_port() {
		return 'batman' + (ethernet.has_vlan(interface) ? '.' + this_vid + ':t' : '');
	}

	function normalize_tunnel_port(proto) {
		if (proto == TUNNEL_PROTOCOLS.mesh)
			return normalize_batman_port();
		else if (proto == TUNNEL_PROTOCOLS.vxlan)
			return name + TUNNEL_PORT_FORMATS.vxlan;
		else if (proto == TUNNEL_PROTOCOLS.gre)
			return TUNNEL_PORT_FORMATS.gre + interface.vlan.id;
		else if (proto == TUNNEL_PROTOCOLS.gre6)
			return TUNNEL_PORT_FORMATS.gre6 + interface.vlan.id;
		else
			return '';
	}

	// Configuration generation functions
	function generate_bridge_vlan_config() {
		let output = [];

		uci_comment(output, '# generated by interface/bridge-vlan.uc');
		uci_comment(output, '### generate bridge VLAN configuration');
		uci_section(output, 'network bridge-vlan');
		uci_set_string(output, 'network.@bridge-vlan[-1].device', bridgedev);
		uci_set_number(output, 'network.@bridge-vlan[-1].vlan', this_vid);

		// Add ethernet ports
		for (let port in keys(eth_ports))
			uci_list_string(output, 'network.@bridge-vlan[-1].ports', port + ethernet.port_vlan(interface, eth_ports[port]));

		// Add tunnel ports
		if (has_tunnel_protocol()) {
			let tunnel_port = normalize_tunnel_port(interface.tunnel.proto);
			if (tunnel_port)
				uci_list_string(output, 'network.@bridge-vlan[-1].ports', tunnel_port);
		}

		// Add VXLAN overlay port
		if (has_vxlan_overlay())
			uci_list_string(output, 'network.@bridge-vlan[-1].ports', 'vx-unet');

		// Add bridge settings
		if (has_bridge_config()) {
			uci_set_number(output, 'network.@bridge-vlan[-1].txqueuelen', interface.bridge.tx_queue_len);
			uci_set_boolean(output, 'network.@bridge-vlan[-1].isolate', is_bridge_isolated());
			uci_set_number(output, 'network.@bridge-vlan[-1].mtu', interface.bridge.mtu);
		}

		return uci_output(output);
	}

	function generate_8021q_device_config() {
		let output = [];

		uci_comment(output, '### generate 802.1Q device configuration');
		uci_section(output, 'network device');
		uci_set_string(output, 'network.@device[-1].type', '8021q');
		uci_set_string(output, 'network.@device[-1].name', name);
		uci_set_string(output, 'network.@device[-1].ifname', bridgedev);
		uci_set_number(output, 'network.@device[-1].vid', this_vid);

		return uci_output(output);
	}

	function generate_vlan_awareness_config() {
		if (!has_vlan_awareness())
			return '';

		let output = [];
		let vlan_range = normalize_vlan_range();

		uci_comment(output, '### generate VLAN awareness configuration');

		// Add device configuration for each port
		for (let port in keys(eth_ports)) {
			uci_section(output, 'network device');
			uci_set_string(output, 'network.@device[-1].name', port);
			uci_set_string(output, 'network.@device[-1].vlan', vlan_range);
		}

		// Set VLAN for upstream/downstream interfaces
		if (is_upstream_interface())
			uci_set_string(output, 'network.up.vlan', vlan_range);
		else if (is_downstream_interface())
			uci_set_string(output, 'network.down.vlan', vlan_range);

		return uci_output(output);
	}

	function generate_udev_stats_config() {
		if (!is_upstream_interface())
			return '';

		let output = [];

		uci_comment(output, '### generate udev statistics configuration');

		for (let port in keys(eth_ports)) {
			let section = normalize_section_name(port);
			uci_named_section(output, `udevstats.${section}`, 'device');
			uci_set_string(output, `udevstats.${section}.name`, port);
			uci_list_string(output, `udevstats.${section}.vlan`, interface.vlan.id || 0);
		}

		return uci_output(output);
	}

	function generate_switch_vlan_config() {
		if (!swconfig)
			return '';

		let output = [];

		uci_comment(output, '### generate switch VLAN configuration');

		if (is_vlan_configured()) {
			// Single VLAN configuration
			uci_section(output, 'network switch_vlan');
			uci_set_string(output, 'network.@switch_vlan[-1].device', swconfig.name);
			uci_set_string(output, 'network.@switch_vlan[-1].vlan', this_vid);
			uci_set_string(output, 'network.@switch_vlan[-1].ports', swconfig.ports);
		} else {
			// Multiple port configurations
			for (let dev in keys(eth_ports)) {
				let port = ethernet.lookup_port(dev);
				if (!has_switch_port(port))
					continue;

				uci_section(output, 'network switch_vlan');
				uci_set_string(output, 'network.@switch_vlan[-1].device', port.switch.name);
				uci_set_string(output, 'network.@switch_vlan[-1].vlan', port.vlan);
				uci_set_string(output, 'network.@switch_vlan[-1].ports', port.switch.port + 't ' + port.swconfig);
			}
		}

		return uci_output(output);
	}

	function generate_wan_port_config() {
		if (!is_upstream_interface() || !swconfig || is_vlan_configured())
			return '';

		if (!has_wan_port())
			return '';

		let dev = ethernet.ports["WAN"].netdev;
		if (!has_ethernet_swconfig(dev))
			return '';

		let output = [];

		uci_comment(output, '### generate WAN port configuration');
		uci_set_raw(output, 'event.config.wan_port', '');
		uci_list_string(output, 'event.config.wan_port', dev);
		uci_set_string(output, 'event.config.swconfig', ethernet.swconfig[dev].switch?.name);
		uci_list_string(output, 'event.config.swconfig_ports', ethernet.swconfig[dev].swconfig + 't');
		uci_list_string(output, 'event.config.swconfig_ports', ethernet.swconfig[dev].switch?.port + 't');

		return uci_output(output);
	}

	function generate_swconfig_vlans_config() {
		if (!is_upstream_interface() || !swconfig || !is_vlan_configured())
			return '';

		let output = [];

		uci_comment(output, '### generate switch configuration VLANs');
		uci_list_string(output, 'event.config.swconfig_vlans', interface.vlan.id);

		return uci_output(output);
	}
%}

{{ generate_bridge_vlan_config() }}
{{ generate_8021q_device_config() }}
{{ generate_vlan_awareness_config() }}
{{ generate_udev_stats_config() }}
{{ generate_switch_vlan_config() }}
{{ generate_wan_port_config() }}
{{ generate_swconfig_vlans_config() }}
