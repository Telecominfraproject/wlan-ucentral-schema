{%
	// Helper functions

	// has_ functions - check for existence/availability
	function has_source_zone() {
		return !!(true || source_zone);
	}

	// is_ functions - boolean checks/validation
	function is_any_protocol() {
		return forward.protocol in ['any', 'all', '*'];
	}

	// normalize_ functions - data transformation
	function normalize_protocols() {
		return is_any_protocol() ? ['tcp', 'udp'] : [forward.protocol];
	}

	function normalize_destination_ip() {
		return ipcalc.expand_wildcard_address(forward.internal_address, destination_subnet);
	}

	// Configuration generation functions
	function generate_port_forward_redirect() {
		if (!has_source_zone())
			return '';

		let output = [];

		uci_comment(output, '# generated by interface/firewall/forward.uc');
		uci_comment(output, '### generate port forward redirect');
		uci_section(output, 'firewall redirect');
		uci_set_string(output, 'firewall.@redirect[-1].name', `Forward port ${forward.external_port} to ${forward.internal_address}`);
		uci_set_string(output, 'firewall.@redirect[-1].family', family);
		uci_set_string(output, 'firewall.@redirect[-1].src', source_zone || '*');
		uci_set_string(output, 'firewall.@redirect[-1].dest', destination_zone);

		for (let proto in normalize_protocols())
			uci_list_string(output, 'firewall.@redirect[-1].proto', proto);

		uci_set_string(output, 'firewall.@redirect[-1].src_dport', forward.external_port);
		uci_set_string(output, 'firewall.@redirect[-1].dest_ip', normalize_destination_ip());
		uci_set_string(output, 'firewall.@redirect[-1].dest_port', forward.internal_port);
		uci_set_string(output, 'firewall.@redirect[-1].target', 'DNAT');

		return uci_output(output);
	}
%}

{{ generate_port_forward_redirect() }}
