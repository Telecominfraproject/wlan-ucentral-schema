{%
	// Constants
	const DHCPV6_HYBRID_RA_FLAGS = [ 'other-config', 'managed-config' ];
	const DHCPV6_STATEFUL_RA_FLAGS = [ 'other-config', 'managed-config' ];
	const DHCPV6_STATELESS_RA_FLAGS = [ 'other-config' ];

	name = ethernet.calculate_name(interface);
	dhcp = ipv4.dhcp || { ignore: 1 };
	dhcpv6 = ipv6.dhcpv6 || {};

	// Helper functions

	// has_ functions - check for existence/availability
	function has_dhcp_dns() {
		return !!dhcp.use_dns;
	}

	function has_dhcpv6_dns() {
		return length(dhcpv6.announce_dns) > 0;
	}

	function has_dhcp_leases() {
		return interface.ipv4?.dhcp_leases && length(interface.ipv4.dhcp_leases) > 0;
	}

	// is_ functions - boolean checks/validation
	function is_upstream_interface() {
		return interface.role == 'upstream';
	}

	function is_dhcpv6_mode(mode) {
		return dhcpv6.mode == mode;
	}

	// match_ functions - value mapping/selection
	function match_dhcpv6_ra_flags(mode) {
		if (mode == 'hybrid')
			return DHCPV6_HYBRID_RA_FLAGS;
		else if (mode == 'stateful')
			return DHCPV6_STATEFUL_RA_FLAGS;
		else if (mode == 'stateless')
			return DHCPV6_STATELESS_RA_FLAGS;
		else
			return [];
	}

	function match_relay_status(enabled) {
		return enabled ? 'relay' : 'disabled';
	}

	// normalize_ functions - data transformation
	function normalize_dns_option() {
		let ret = '';

		if (type(dhcp.use_dns) == 'array') {
			for (let k, v in dhcp.use_dns)
				ret += ',' + v;
		} else {
			ret += ',' + dhcp.use_dns;
		}

		return '6' + ret;
	}

	// Configuration generation functions
	function generate_dhcp_base_config() {
		let output = [];

		uci_comment(output, '# generated by interface/dhcp.uc');
		uci_comment(output, '### generate DHCP base configuration');
		uci_named_section(output, `dhcp.${name}`, 'dhcp');
		uci_set_string(output, `dhcp.${name}.interface`, ethernet.calculate_ipv4_name(interface));
		uci_set_number(output, `dhcp.${name}.start`, dhcp.lease_first);
		uci_set_number(output, `dhcp.${name}.limit`, dhcp.lease_count);
		uci_set_string(output, `dhcp.${name}.leasetime`, dhcp.lease_time);
		uci_set_boolean(output, `dhcp.${name}.ignore`, dhcp.ignore);

		if (has_dhcp_dns())
			uci_list_string(output, `dhcp.${name}.dhcp_option`, normalize_dns_option());

		return uci_output(output);
	}

	function generate_dhcpv6_downstream_config() {
		if (is_upstream_interface())
			return '';

		let output = [];

		uci_comment(output, '### generate DHCPv6 downstream configuration');

		if (is_dhcpv6_mode('hybrid')) {
			uci_set_string(output, `dhcp.${name}.ra`, 'server');
			uci_set_string(output, `dhcp.${name}.dhcpv6`, 'server');
			uci_set_string(output, `dhcp.${name}.ndp`, 'disabled');
			uci_set_number(output, `dhcp.${name}.ra_slaac`, 1);
			for (let flag in DHCPV6_HYBRID_RA_FLAGS)
				uci_list_string(output, `dhcp.${name}.ra_flags`, flag);
		} else if (is_dhcpv6_mode('stateful')) {
			uci_set_string(output, `dhcp.${name}.ra`, 'server');
			uci_set_string(output, `dhcp.${name}.dhcpv6`, 'server');
			uci_set_string(output, `dhcp.${name}.ndp`, 'disabled');
			uci_set_number(output, `dhcp.${name}.ra_slaac`, 0);
			for (let flag in DHCPV6_STATEFUL_RA_FLAGS)
				uci_list_string(output, `dhcp.${name}.ra_flags`, flag);
		} else if (is_dhcpv6_mode('stateless')) {
			uci_set_string(output, `dhcp.${name}.ra`, 'server');
			uci_set_string(output, `dhcp.${name}.dhcpv6`, 'server');
			uci_set_string(output, `dhcp.${name}.ndp`, 'disabled');
			uci_set_number(output, `dhcp.${name}.ra_slaac`, 1);
			for (let flag in DHCPV6_STATELESS_RA_FLAGS)
				uci_list_string(output, `dhcp.${name}.ra_flags`, flag);
		} else if (is_dhcpv6_mode('relay')) {
			uci_set_string(output, `dhcp.${name}.ra`, 'relay');
			uci_set_string(output, `dhcp.${name}.dhcpv6`, 'relay');
			uci_set_string(output, `dhcp.${name}.ndp`, 'relay');
		} else {
			uci_set_string(output, `dhcp.${name}.ra`, 'disabled');
			uci_set_string(output, `dhcp.${name}.dhcpv6`, 'disabled');
			uci_set_string(output, `dhcp.${name}.ndp`, 'disabled');
		}

		uci_set_string(output, `dhcp.${name}.prefix_filter`, dhcpv6.filter_prefix);
		uci_set_boolean(output, `dhcp.${name}.dns_service`, !length(dhcpv6.announce_dns));

		for (let i, addr in dhcpv6.announce_dns)
			uci_list_string(output, `dhcp.${name}.dns`, addr);

		return uci_output(output);
	}

	function generate_dhcpv6_upstream_config() {
		if (!is_upstream_interface())
			return '';

		let output = [];

		uci_comment(output, '### generate DHCPv6 upstream configuration');
		uci_set_boolean(output, `dhcp.${name}.master`, has_downstream_relays);
		uci_set_string(output, `dhcp.${name}.ra`, match_relay_status(has_downstream_relays));
		uci_set_string(output, `dhcp.${name}.dhcpv6`, match_relay_status(has_downstream_relays));
		uci_set_string(output, `dhcp.${name}.ndp`, match_relay_status(has_downstream_relays));

		return uci_output(output);
	}

	function generate_dhcp_leases_config() {
		if (!has_dhcp_leases())
			return '';

		let output = [];

		uci_comment(output, '### generate DHCP static leases');

		for (let lease in interface.ipv4.dhcp_leases) {
			uci_section(output, 'dhcp host');
			uci_set_string(output, 'dhcp.@host[-1].hostname', lease.hostname);
			uci_set_string(output, 'dhcp.@host[-1].mac', lease.macaddr);
			uci_set_string(output, 'dhcp.@host[-1].ip', lease.static_lease_offset);
			uci_set_string(output, 'dhcp.@host[-1].leasetime', lease.lease_time);
			uci_set_string(output, 'dhcp.@host[-1].instance', name);
		}

		return uci_output(output);
	}
%}

{{ generate_dhcp_base_config() }}
{{ generate_dhcpv6_downstream_config() }}
{{ generate_dhcpv6_upstream_config() }}
{{ generate_dhcp_leases_config() }}
