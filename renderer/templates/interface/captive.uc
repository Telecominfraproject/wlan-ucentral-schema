{%
	// Constants
	const WEB_ROOT_PATHS = {
		temp_dir: '/tmp/ucentral',
		www_dir: '/tmp/ucentral/www-uspot',
		web_root_tar: '/tmp/ucentral/web-root.tar',
		system_webroot: '/etc/ucentral/web-root.tar.gz',
		default_www: '/www-uspot'
	};

	const RADIUS_DEFAULTS = {
		auth_server: '127.0.0.1',
		auth_port: '1812',
		acct_server: '127.0.0.1',
		acct_port: '1813'
	};

	const UHTTPD_DEFAULTS = {
		redirect_https: '0',
		rfc1918_filter: '1',
		max_requests: '5',
		max_connections: '100',
		cert: '/etc/uhttpd.crt',
		key: '/etc/uhttpd.key',
		script_timeout: '60',
		network_timeout: '30',
		http_keepalive: '20',
		tcp_keepalive: '1',
		home: '/tmp/ucentral/www-uspot'
	};

	const UAM_PREFIXES = [
		'/logon=/usr/share/uspot/handler-uam.uc',
		'/logoff=/usr/share/uspot/handler-uam.uc',
		'/logout=/usr/share/uspot/handler-uam.uc'
	];

	// Helper functions

	// has_ functions - check for existence/availability
	function has_web_root() {
		return !!config.web_root;
	}

	function has_web_root_url() {
		return !!config.web_root_url;
	}

	function has_credentials() {
		return config.credentials && length(config.credentials) > 0;
	}

	function has_acct_server() {
		return !!config.acct_server;
	}

	// is_ functions - boolean checks/validation
	function is_radius_mode() {
		return config.auth_mode in ['radius', 'uam'];
	}

	function is_credentials_mode() {
		return config.auth_mode == 'credentials';
	}

	function is_uam_mode() {
		return config.auth_mode == 'uam';
	}

	function is_radius_proxy_enabled() {
		return !!config.radius_gw_proxy;
	}

	// normalize_ functions - data transformation
	function normalize_serial_for_radius() {
		return replace(serial, /^(..)(..)(..)(..)(..)(..)$/, "$1$2$3$4$5$6");
	}

	function normalize_challenge() {
		let challenge = "";
		for (let i = 0; i < 16; i++)
			challenge += sprintf('%02x', math.rand() % 255);
		return challenge;
	}

	// Utility functions
	function radius_proxy_tlv(server, port, name) {
		return normalize_serial_for_radius() + sprintf(":%s:%s:%s", server, port, name);
	}

	function setup_web_root() {
		if (has_web_root()) {
			fs.mkdir(WEB_ROOT_PATHS.www_dir);
			let web_root = fs.open(WEB_ROOT_PATHS.web_root_tar, 'w');
			web_root.write(b64dec(config.web_root));
			web_root.close();
			shell.system(`tar x -C ${WEB_ROOT_PATHS.www_dir} -f ${WEB_ROOT_PATHS.web_root_tar}`);
		} else if (has_web_root_url()) {
			shell.system(`/usr/share/ucentral/download-webroot.sh ${config.web_root_url} ${config.web_root_checksum}`);
			let stat = fs.stat(WEB_ROOT_PATHS.system_webroot);
			if (!stat) {
				warn('unable to download captive portal web-root');
				return false;
			}
			fs.mkdir(WEB_ROOT_PATHS.www_dir);
			shell.system(`tar xz -C ${WEB_ROOT_PATHS.www_dir} -f ${WEB_ROOT_PATHS.system_webroot}`);
		} else {
			fs.mkdir(WEB_ROOT_PATHS.temp_dir);
			shell.system(`cp -r ${WEB_ROOT_PATHS.default_www} ${WEB_ROOT_PATHS.temp_dir}/`);
		}
		return true;
	}

	// Configuration generation functions
	function generate_uspot_base_config() {
		let output = [];

		uci_comment(output, '# generated by interface/captive.uc');
		uci_comment(output, '### generate Captive Portal service configuration');
		uci_named_section(output, `uspot.${section}`, 'uspot');
		uci_set_string(output, `uspot.${section}.auth_mode`, config.auth_mode);
		uci_set_boolean(output, `uspot.${section}.web_root`, config.web_root);
		uci_set_number(output, `uspot.${section}.idle_timeout`, config.idle_timeout);
		uci_set_number(output, `uspot.${section}.session_timeout`, config.session_timeout);

		return uci_output(output);
	}

	function generate_radius_config() {
		if (!is_radius_mode())
			return '';

		let output = [];

		uci_comment(output, '### generate RADIUS configuration');

		if (is_radius_proxy_enabled()) {
			uci_set_string(output, `uspot.${section}.auth_server`, RADIUS_DEFAULTS.auth_server);
			uci_set_string(output, `uspot.${section}.auth_port`, RADIUS_DEFAULTS.auth_port);
			uci_set_string(output, `uspot.${section}.auth_proxy`, radius_proxy_tlv(config.auth_server, config.auth_port, 'captive'));

			if (has_acct_server()) {
				uci_set_string(output, `uspot.${section}.acct_server`, RADIUS_DEFAULTS.acct_server);
				uci_set_string(output, `uspot.${section}.acct_port`, RADIUS_DEFAULTS.acct_port);
				uci_set_string(output, `uspot.${section}.acct_proxy`, radius_proxy_tlv(config.acct_server, config.acct_port, 'captive'));
			}
		} else {
			uci_set_string(output, `uspot.${section}.auth_server`, config.auth_server);
			uci_set_string(output, `uspot.${section}.auth_port`, config.auth_port);
			uci_set_string(output, `uspot.${section}.acct_server`, config.acct_server);
			uci_set_string(output, `uspot.${section}.acct_port`, config.acct_port);
		}

		uci_set_string(output, `uspot.${section}.auth_secret`, config.auth_secret);
		uci_set_string(output, `uspot.${section}.acct_secret`, config.acct_secret);
		uci_set_number(output, `uspot.${section}.acct_interval`, config.acct_interval);

		return uci_output(output);
	}

	function generate_credentials_config() {
		if (!is_credentials_mode() || !has_credentials())
			return '';

		let output = [];

		uci_comment(output, '### generate credentials configuration');

		for (let cred in config.credentials) {
			uci_section(output, 'uspot credentials');
			uci_set_string(output, 'uspot.@credentials[-1].username', cred.username);
			uci_set_string(output, 'uspot.@credentials[-1].password', cred.password);
			uci_set_string(output, 'uspot.@credentials[-1].interface', section);
		}

		return uci_output(output);
	}

	function generate_uam_config() {
		if (!is_uam_mode())
			return '';

		let output = [];
		let challenge = normalize_challenge();

		uci_comment(output, '### generate UAM configuration');
		uci_set_string(output, `uspot.${section}.challenge`, challenge);
		uci_set_string(output, `uspot.${section}.uam_port`, config.uam_port);
		uci_set_string(output, `uspot.${section}.uam_secret`, config.uam_secret);
		uci_set_string(output, `uspot.${section}.uam_server`, config.uam_server);
		uci_set_string(output, `uspot.${section}.nasid`, config.nasid);
		uci_set_string(output, `uspot.${section}.nasmac`, config.nasmac || serial);
		uci_set_string(output, `uspot.${section}.ssid`, config.ssid);
		uci_set_string(output, `uspot.${section}.mac_format`, config.mac_format);
		uci_set_string(output, `uspot.${section}.final_redirect_url`, config.final_redirect_url);
		uci_set_boolean(output, `uspot.${section}.mac_auth`, config.mac_auth);

		return uci_output(output);
	}

	function generate_uam_uhttpd_config() {
		if (!is_uam_mode())
			return '';

		let output = [];

		uci_comment(output, '### generate UAM HTTP server configuration');
		uci_named_section(output, `uhttpd.uam${config.uam_port}`, 'uhttpd');
		uci_set_string(output, `uhttpd.@uhttpd[-1].redirect_https`, UHTTPD_DEFAULTS.redirect_https);
		uci_set_string(output, `uhttpd.@uhttpd[-1].rfc1918_filter`, UHTTPD_DEFAULTS.rfc1918_filter);
		uci_set_string(output, `uhttpd.@uhttpd[-1].max_requests`, UHTTPD_DEFAULTS.max_requests);
		uci_set_string(output, `uhttpd.@uhttpd[-1].max_connections`, UHTTPD_DEFAULTS.max_connections);
		uci_set_string(output, `uhttpd.@uhttpd[-1].cert`, UHTTPD_DEFAULTS.cert);
		uci_set_string(output, `uhttpd.@uhttpd[-1].key`, UHTTPD_DEFAULTS.key);
		uci_set_string(output, `uhttpd.@uhttpd[-1].script_timeout`, UHTTPD_DEFAULTS.script_timeout);
		uci_set_string(output, `uhttpd.@uhttpd[-1].network_timeout`, UHTTPD_DEFAULTS.network_timeout);
		uci_set_string(output, `uhttpd.@uhttpd[-1].http_keepalive`, UHTTPD_DEFAULTS.http_keepalive);
		uci_set_string(output, `uhttpd.@uhttpd[-1].tcp_keepalive`, UHTTPD_DEFAULTS.tcp_keepalive);
		uci_list_string(output, `uhttpd.@uhttpd[-1].listen_http`, `0.0.0.0:${config.uam_port}`);
		uci_list_string(output, `uhttpd.@uhttpd[-1].listen_http`, `[::]:${config.uam_port}`);
		uci_set_string(output, `uhttpd.@uhttpd[-1].home`, UHTTPD_DEFAULTS.home);

		for (let prefix in UAM_PREFIXES)
			uci_list_string(output, `uhttpd.@uhttpd[-1].ucode_prefix`, prefix);

		return uci_output(output);
	}

	function generate_uam_firewall_rules() {
		if (!is_uam_mode())
			return '';

		let output = [];

		uci_comment(output, '### generate UAM firewall rules');

		// First UAM rule
		uci_named_section(output, `firewall.${name + config.uam_port}_1`, 'rule');
		uci_set_string(output, `firewall.@rule[-1].name`, `Allow-UAM-${name}`);
		uci_set_string(output, `firewall.@rule[-1].src`, name);
		uci_set_string(output, `firewall.@rule[-1].dest_port`, config.uam_port);
		uci_set_string(output, `firewall.@rule[-1].proto`, 'tcp');
		uci_set_string(output, `firewall.@rule[-1].target`, 'ACCEPT');
		uci_set_string(output, `firewall.@rule[-1].mark`, '1/127');

		// Second UAM rule
		uci_named_section(output, `firewall.${name + config.uam_port}_2`, 'rule');
		uci_set_string(output, `firewall.@rule[-1].name`, `Allow-UAM-${name}`);
		uci_set_string(output, `firewall.@rule[-1].src`, name);
		uci_set_string(output, `firewall.@rule[-1].dest_port`, config.uam_port);
		uci_set_string(output, `firewall.@rule[-1].proto`, 'tcp');
		uci_set_string(output, `firewall.@rule[-1].target`, 'ACCEPT');
		uci_set_string(output, `firewall.@rule[-1].mark`, '2/127');

		return uci_output(output);
	}

	// Main logic
	if (config.radius_gw_proxy)
		services.set_enabled("radius-gw-proxy", true);

	captive.interface(section, config);
	let name = split(section, '_')[0];

	if (!setup_web_root())
		return;

	if (captive.radius_gw_proxy)
		services.set_enabled("radius-gw-proxy", true);
%}

{{ generate_uspot_base_config() }}
{{ generate_radius_config() }}
{{ generate_credentials_config() }}
{{ generate_uam_config() }}
{{ generate_uam_uhttpd_config() }}
{{ generate_uam_firewall_rules() }}
